/* Based on the c file generated by Matlab and SPIKY_futureSPIKE_MEX.c
 * Mex file doing the computation from MAP_finalForLoop.m, to be run by MAP_only_AN (end of the function)
 * Inputs: See list below. ANprobas_in is the matrix in which the output will be put.
 * All inputs are double arrays, except for vectInd that is expected to be int32
 * Output: None at the moment. Code given below if we want to allocate memory and make an output.
 * Beware: The values of AN_available, AN_reprocess and AN_cleft are also changed by the MEX file
 * Run in Matlab "mex MAP_finalForLoop_mex_Alban.c" to use this file.
*/
 
#include "mex.h"
#include "matrix.h"
#include <stdlib.h>
#include <time.h>     /* To reinitialise randomness */
#include <math.h>     /* For pow() power function */

 /* Redefine function intpow for doubles (a to the power floor(b)), 
  because unsure how to call function for mex.
  Replace by call to initial intpow when knows how-to */
double intpow( double a, double b){
  return pow(a, floor(b));}

/* Calculate a random refractory period */
int getRefractoryPeriod (int AbsRefInt){
  return (int) AbsRefInt + round((rand()/RAND_MAX) * AbsRefInt);}

/* Logical check that current proba bigger than rand() (Poisson generation) */
double isBiggerThanRand(double prob){
  return prob > (double) rand() / RAND_MAX;}

void mexFunction(int nlhs, mxArray *plhs[],int nrhs, const mxArray *prhs[])
{
  /* Output // Not necessary because predefined matrix given as first input ANprobas_in */
  #define ANprobas_out plhs[0]

  /* Inputs */
  #define nFibersPerChannel_in prhs[0]
  #define releaseProbFull_in prhs[1]
  #define AN_available_in prhs[2]
  #define AN_reprocess_in prhs[3]
  #define AN_M_in prhs[4]
  #define AN_xdt_in prhs[5]
  #define AN_ydt_in prhs[6]
  #define AN_rdt_plus_ldt_in prhs[7]
  #define AN_rdt_in prhs[8]
  #define AN_cleft_in prhs[9]
  #define vectInd_in prhs[10]
  #define lengthAbsRefractory_in prhs[11]

  /* Variables */
  int kk;           /* Loop index */
  int count_spk;    /* Loop index for spikes array */
  int ind = -1;     /* Running index */
  int row_release = -1; /* Running index for release array */
  int ANtimeCount;  /* Index columns */
  int row;          /* Index row */
  int nPointsRef;   /* Random refractory period */
  int AbsRefInt;    /* Minimal refractory period */
  int nFibPerChan;  /* Number of fibers per channel */
  int *vectInd;     /* Inputs need to be given using int32 (in Matlab) */
  double M_q, ejected, reuptake, reprocessed, releaseProb, replenish, reuptakelost;
  double prob_ejec, prob_repr, prob_repl;      /* Probabilities */
  double *AN_rdt_plus_ldt, *releaseProbFull, *AN_M, *AN_rdt, *AN_xdt, *AN_ydt;
  double *AN_cleft, *AN_available, *AN_reprocess, *lengthAbsRef, *nFibPerChan_doub;
  double *ANprobas; /* Booleans of minimal size: https://fr.mathworks.com/matlabcentral/newsreader/view_thread/159081 */
  

  /* Copy original input vectors */
  AN_rdt            = (double *)mxGetPr(AN_rdt_in);
  AN_xdt            = (double *)mxGetPr(AN_xdt_in);
  AN_ydt            = (double *)mxGetPr(AN_ydt_in);
  AN_cleft          = (double *)mxGetPr(AN_cleft_in);
  AN_available      = (double *)mxGetPr(AN_available_in);
  AN_reprocess      = (double *)mxGetPr(AN_reprocess_in);
  releaseProbFull   = (double *)mxGetPr(releaseProbFull_in); 
  AN_rdt_plus_ldt   = (double *)mxGetPr(AN_rdt_plus_ldt_in);
  AN_M              = (double *)mxGetPr(AN_M_in);
  vectInd           = (int *)mxGetPr(vectInd_in); /* Not used at the moment */ 
  lengthAbsRef      = (double *)mxGetPr(lengthAbsRefractory_in); /* length of refractory period */
  AbsRefInt         = (int) *lengthAbsRef;
  /* nFibPerChan_doub  = (double *)mxGetPr(nFibersPerChannel_in); */ /* Used to be for fiber generation */
  nFibPerChan       = 1; /* (int) *nFibPerChan_doub; */ 
  
  int ANprob_sizeM, ANprob_sizeN; /* size_t ANprob_sizeM, ANprob_sizeN;*/
  ANprob_sizeM = nFibPerChan * mxGetM(releaseProbFull_in);
  ANprob_sizeN = mxGetN(releaseProbFull_in);
  


  if (mxGetM(AN_available_in) != ANprob_sizeM){     mexErrMsgTxt("Size of AN_available_in not as expected\n"); }
  if (mxGetM(AN_reprocess_in) != ANprob_sizeM){     mexErrMsgTxt("Size of AN_reprocess_in not as expected\n"); }
  if (mxGetM(AN_xdt_in) != ANprob_sizeM){           mexErrMsgTxt("Size of AN_xdt_in not as expected\n"); }
  if (mxGetM(AN_ydt_in) != ANprob_sizeM){           mexErrMsgTxt("Size of AN_ydt_in not as expected\n"); }
  if (mxGetM(AN_rdt_plus_ldt_in) != ANprob_sizeM){  mexErrMsgTxt("Size of AN_rdt_plus_ldt_in not as expected\n"); }
  if (mxGetM(AN_rdt_in) != ANprob_sizeM){           mexErrMsgTxt("Size of AN_rdt_in not as expected\n"); }
  if (mxGetM(AN_cleft_in) != ANprob_sizeM){         mexErrMsgTxt("Size of AN_cleft_in not as expected\n"); }

  /* Code to use if we want to have ANspike as input
  //ANprobas = (bool *) mxGetLogicals(ANprobas_in);
  */
  
   
  /* Code to use if we want to use an output (ANprobas_out instead of ANprobas_in): get sizes and allocate memory*/

  /* Prepare output (mwSignedIndex?) */
  mwSize dims[2];
  dims[0] = (mwSize)ANprob_sizeM;
  dims[1] = (mwSize)ANprob_sizeN;

  ANprobas_out = mxCreateDoubleMatrix(dims[0], dims[1], mxREAL);
  /* ANprobas_out = mxCreateNumericArray(2, dims, mxDOUBLE_CLASS, mxREAL); */
  /*mxSetM(ANprobas_out, (int) dims[0]);
  mxSetN(ANprobas_out, (int) dims[1]);*/
  /* mxSetData(ANprobas_out, mxMalloc((mwSize) sizeof(double) * dims[0] * dims[1])); */
  
  /* ANprobas = (mxLogical *) mxGetPr(ANprobas_out); */
  ANprobas = (double *)mxGetPr(ANprobas_out);

  /* Initialise randomness used (or fix it by replacing with srand(123) for example) */
  srand ( time(NULL) );  /* printf("%f\n", (float) RAND_MAX); */

  /*  Main body: loop over columns, loop over rows. */
  for (ANtimeCount = 0; ANtimeCount < ANprob_sizeN ; ANtimeCount++) {
    for (row = 0; row < ANprob_sizeM; row++){

    /* The row for releaseFull should be constant for nFibPerChan values of "row" * /
    row_release = (int) floor((double) row / (double) nFibPerChan); 
    / * This is the index, row-major, for releaseProbFull * /
    row_release = ANprob_sizeN * row_release - 1; 
    */


      /* Current index for releaseProbFull */
      /*row_release++; */
      ind++;

      /* Number of missing vesicles (non-negative) */
      M_q = *AN_M - AN_available[row]; 
      if (M_q < 0){  M_q = 0; }

      /* Temporary Variables: */
      /* - Deterministic */
      ejected      = releaseProbFull[ind] * AN_available[row];
      reuptakelost = AN_rdt_plus_ldt[row] * AN_cleft[row];
      reuptake     = AN_rdt[row] * AN_cleft[row];      
      reprocessed  = AN_xdt[row] * AN_reprocess[row];
      replenish    = AN_ydt[row] * M_q;


      /* - Random */ 
      /* Since we assumed releaseProbFull has one fiber per channel, it must be constant nFibPerChan times in a row */
      /*prob_ejec = 1-intpow(1 - releaseProbFull[row_release], AN_available[row]);
      prob_repr   = 1-intpow(1 - AN_xdt[row], AN_reprocess[row]);
      prob_repl   = 1-intpow(1 - AN_ydt[row], M_q);
      ejected     = isBiggerThanRand(prob_ejec);
      reprocessed = isBiggerThanRand(prob_repr);
      replenish   = isBiggerThanRand(prob_repl);*/

      /*  These are is the pointers to the original arrays, so the Matlab inputs are changed as well */
      AN_available[row] = AN_available[row] + replenish - ejected + reprocessed; 
      AN_cleft[row]     = AN_cleft[row] + ejected - reuptakelost;
      AN_reprocess[row] = AN_reprocess[row] + reuptake - reprocessed;

      /* Save in the current index */
      ANprobas[ind] = ejected;

    }
  }

  /* Deallocate mxArray, even though Matlab is supposed to do it; may cause a crash */
  /* mxDestroyArray((mxArray *)ANprobas); */
  return;
}
